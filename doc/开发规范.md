# Drift Protocol DLOB 做市机器人开发规范

本规范用于指导 LLM 完成一个运行于 Drift Protocol (Solana) 的去中心化限价订单簿（DLOB）合约做市机器人的全量开发。机器人采用事件驱动架构，支持 Web 管理后台，所有配置可通过前端热重载。

---

## 1 项目概述与技术栈

### 1.1 项目目标

构建一个完全运行于 Drift Protocol 的 DLOB 做市机器人，具备以下核心能力：基于预言机的动态报价、原子性订单更新、库存感知的价差调整、完善的日志与监控、以及配套的 HTMX+Tailwind 管理前台。

### 1.2 技术栈

| 层级         | 技术选型                          | 说明                                       |
| ------------ | --------------------------------- | ------------------------------------------ |
| 运行时       | Node.js (v20+)                    | 必须使用 Node.js 原生支持的大型项目        |
| 语言         | TypeScript (Strict Mode)          | 严格模式，所有类型必须显式声明             |
| 执行环境     | TSX                               | 直接运行 TypeScript 文件，无需编译步骤     |
| 配置管理     | TOML + Dotenv                     | config.toml 存放策略参数，.env 存放私钥    |
| 数据库       | SQLite                            | 使用 better-sqlite3 或 prisma 存储账户快照 |
| 前端         | HTMX + Tailwind CSS               | SSR 渲染 + 无刷新交互                      |
| Solana/Drift | @drift-labs/sdk + @solana/web3.js | 官方 SDK 必须使用 v2 版本                  |

### 1.3 目录结构

项目应遵循清晰的模块化划分，每个模块对应一个独立目录。整体目录结构如下：

```
drift-mm-bot/
├── config/
│   ├── config.toml          # 策略参数配置文件（可热重载）
│   ├── ConfigManager.ts    # 配置加载、校验、热重载监听
│   └── schema.ts           # 配置类型定义
├── src/
│   ├── index.ts            # 程序入口
│   ├── env.ts              # 环境变量加载（私钥）
│   ├── logger/
│   │   ├── Logger.ts       # 主日志类
│   │   └── levels.ts       # 日志级别常量定义
│   ├── drift/
│   │   ├── DriftClientWrapper.ts  # Drift SDK 封装（初始化、订阅）
│   │   ├── OracleWatcher.ts       # 预言机价格监听
│   │   ├── OrderExecutor.ts       # 订单执行（原子 cancel-and-replace）
│   │   └── PositionManager.ts     # 仓位查询与管理
│   ├── strategy/
│   │   ├── Strategy.ts    # 库存感知报价策略
│   │   ├── StateMachine.ts # 做市状态机
│   │   └── types.ts       # 策略类型定义
│   ├── bot/
│   │   ├── BotEngine.ts    # 主循环引擎
│   │   ├── EventHandler.ts # 事件处理
│   │   └── RiskManager.ts  # 风控检查
│   ├── db/
│   │   ├── Database.ts     # SQLite 连接管理
│   │   ├── AccountRepo.ts  # 账户权益记录
│   │   └── migrations/     # 数据库迁移脚本
│   └── web/
│       ├── server.ts       # HTTP 服务器入口
│       ├── routes/
│       │   ├── api.ts      # API 路由
│       │   └── pages.ts    # 页面路由
│       └── components/     # HTMX 组件
├── logs/                   # 日志输出目录
├── .env                    # 私钥存储（不提交 Git）
├── .env.example            # 环境变量示例
├── .gitignore              # 排除 .env 和 logs
├── package.json
├── tsconfig.json
└── config.toml             # 策略参数配置
```

---

## 2 配置管理模块

### 2.1 环境变量（.env）

环境变量文件必须存放在项目根目录的 `.env` 文件中，内容示例如下：

```
# Solana RPC 节点（推荐使用 Helius 或 QuickNode）
SOLANA_RPC_URL=https://api.mainnet-beta.solana.com

# Drift env
DRIFT_ENV=mainnet-beta

# 钱包私钥（Base58 编码字符串"）
PRIVATE_KEY=
```

重要约束：

- `.env` 文件必须添加到 `.gitignore`，禁止提交到版本控制
- 私钥必须在运行时通过 Dotenv 加载到内存，不持久化到任何日志或数据库
- .env文件中填写的私钥必须是字符串，如果需要数组，则在代码中将其转换

### 2.2 策略配置文件（config.toml）

配置文件采用 TOML 格式，必须支持热重载。以下是必须包含的配置项：

```toml
# 市场配置
[market]
pair = "SOL-PERP"           # 交易对名称
market_index = 0            # Drift 市场索引（SOL-PERP 默认为 0）
leverage = 10               # 杠杆倍数

# 订单参数
[order]
min_order_size = 0.1        # 最小下单数量（SOL）
base_order_size = 1.0      # 基础下单数量（SOL）
spread_bps = 20             # 基础价差（基点，1% = 100bps）
skew_factor = 0.5           # 库存偏移系数（0-1）

# 挂单逻辑
[quoting]
post_only = true            # 必须使用 post-only
cancel_timeout_ms = 30000   # 买单未成交超时时间（毫秒）
price_refresh_threshold = 0.002  # 价格偏移阈值（0.2%）

# 风控参数
[risk]
max_position_size = 10.0   # 最大持仓数量（SOL）
max_usdc_exposure = 10000   # 最大 USDC 敞口
emergency_stop_loss = 0.05  # 止损比例（5%）

# 数据记录
[database]
equity_snapshot_interval_sec = 60  # 账户权益快照间隔（秒）

# 服务器
[server]
port = 3000                 # HTTP 服务端口
```

### 2.3 ConfigManager 类设计

**文件**: `src/config/ConfigManager.ts`

ConfigManager 负责加载配置、校验合法性、监听文件变化并触发热重载。必须实现以下功能：

| 函数                | 职责                    | 输入        | 输出                 |
| ------------------- | ----------------------- | ----------- | -------------------- |
| `load()`            | 读取 config.toml 并解析 | 无          | Config 对象          |
| `validate()`        | 校验配置项合法性        | Config 对象 | void（抛异常则无效） |
| `watch()`           | 监听配置文件变化        | 无          | void                 |
| `get()`             | 获取当前配置快照        | 无          | Config（只读副本）   |
| `update(newConfig)` | 更新配置并触发重载      | Config      | void                 |

关键设计要点：

- ConfigManager 应实现单例模式，确保全局配置一致性
- 每次配置更新时，必须重新校验并触发 `configUpdated` 事件
- 对外提供的 `get()` 必须返回只读副本，防止意外修改

---

## 3 日志系统模块

### 3.1 模块职责

日志系统负责所有模块的统一日志输出，包含控制台彩色输出和文件持久化两部分。日志分级必须严格遵守以下规则：

| 级别  | 名称 | 控制台颜色      | 使用场景                     | 输出文件 |
| ----- | ---- | --------------- | ---------------------------- | -------- |
| DEBUG | 调试 | 灰色（#6b7280） | 详细的SDK调用参数、循环状态  | ✅        |
| INFO  | 信息 | 白色（#ffffff） | 程序运行状态、订单状态变化   | ✅        |
| WARN  | 警告 | 黄色（#fbbf24） | 配置异常、预言机价格偏离     | ✅        |
| ERROR | 错误 | 红色（#ef4444） | 交易失败、异常捕获           | ✅        |
| TRADE | 交易 | 蓝色（#3b82f6） | 订单成交、价格更新、仓位变化 | ✅        |

### 3.2 Logger 类设计

**文件**: `src/logger/Logger.ts`

| 函数                     | 职责             | 输入                           | 输出 |
| ------------------------ | ---------------- | ------------------------------ | ---- |
| `debug(message, meta?)`  | 调试级别日志     | message: string, meta?: object | void |
| `info(message, meta?)`   | 信息级别日志     | message: string, meta?: object | void |
| `warn(message, meta?)`   | 警告级别日志     | message: string, meta?: object | void |
| `error(message, error?)` | 错误级别日志     | message: string, error?: Error | void |
| `trade(message, meta?)`  | 交易关键日志     | message: string, meta?: object | void |
| `setLevel(level)`        | 动态设置日志级别 | LogLevel                       | void |
| `close()`                | 关闭文件句柄     | 无                             | void |

### 3.3 日志格式规范

日志输出必须采用统一格式，便于后续分析和检索：

```
[时间戳] [级别] [模块名] 消息内容 {JSON元数据}
```

示例：

```
[2026-02-24T10:30:45.123Z] [INFO] [BotEngine] 机器人启动成功 {"leverage": 10, "pair": "SOL-PERP"}
[2026-02-24T10:30:46.456Z] [TRADE] [OrderExecutor] 买单成交 {"orderId": "123", "filledSize": 1.0, "price": 98.5}
[2026-02-24T10:31:12.789Z] [ERROR] [DriftClient] 订单失败 {"error": "InsufficientFunds", "orderId": "124"}
```

### 3.4 文件命名规则

日志文件必须按照启动时间精确到秒命名，格式为 `bot_YYYY-MM-DD_HH-mm-ss.log`，存放在项目根目录下的 `logs/` 文件夹中。每个启动周期创建一个新文件，避免单文件过大。

---

## 4 Drift SDK 封装层

### 4.1 DriftClientWrapper 类

**文件**: `src/drift/DriftClientWrapper.ts`

这是整个机器人与 Drift 协议交互的核心封装类。必须在初始化时完成以下步骤：

1. 加载环境变量中的私钥，构建 Wallet 对象
2. 使用 RPC URL 初始化 Connection
3. 创建 DriftClient 实例，传入程序 ID 和连接对象
4. 初始化 SlotSubscriber 用于同步链上状态
5. 订阅用户账户变更事件

| 函数                          | 职责                   | 输入                | 输出                       |
| ----------------------------- | ---------------------- | ------------------- | -------------------------- |
| `initialize()`                | 完整初始化流程         | 无                  | Promise<void>              |
| `getOraclePrice(marketIndex)` | 获取预言机价格         | marketIndex: number | Promise<BN>（整数形式）    |
| `getPosition(marketIndex)`    | 获取当前持仓           | marketIndex: number | Position（包含方向和数量） |
| `getAccountInfo()`            | 获取账户完整信息       | 无                  | UserAccount                |
| `subscribe()`                 | 订阅账户变更事件       | 无                  | Promise<void>              |
| `unsubscribe()`               | 取消订阅（退出时调用） | 无                  | Promise<void>              |

### 4.2 OracleWatcher 类

**文件**: `src/drift/OracleWatcher.ts`

负责持续监听指定市场的预言机价格，并提供价格变化事件。

| 函数                      | 职责               | 输入                | 输出 |
| ------------------------- | ------------------ | ------------------- | ---- |
| `start()`                 | 启动预言机监听     | marketIndex: number | void |
| `stop()`                  | 停止监听           | 无                  | void |
| `getPrice()`              | 获取当前预言机价格 | 无                  | BN   |
| `onPriceUpdate(callback)` | 注册价格变化回调   | (price: BN) => void | void |

关键设计要点：

- 必须使用 Drift SDK 提供的 Oracle 订阅机制，而非自行轮询
- 价格精度处理必须使用 BN（BigNumber），避免浮点误差
- 价格单位为 Drift 内部使用的整数形式，需要正确理解 PRICE_PRECISION

### 4.3 OrderExecutor 类（核心交易执行）

**文件**: `src/drift/OrderExecutor.ts`

这是做市策略执行的核心模块，必须严格实现原子性订单操作。

#### 4.3.1 原子 cancel-and-replace

使用 `cancelAndPlaceOrders` 方法确保取消旧订单和挂新订单在同一交易内完成，避免出现"空窗期"（即订单簿上没有本方报价）。

| 函数                                          | 职责             | 输入                                               | 输出             |
| --------------------------------------------- | ---------------- | -------------------------------------------------- | ---------------- |
| `cancelAndReplace(cancelOrderIds, newOrders)` | 原子性取消并下单 | cancelOrderIds: string[], newOrders: OrderParams[] | Promise<Order[]> |
| `placeOrder(params)`                          | 单笔下单         | OrderParams                                        | Promise<Order>   |
| `cancelOrder(orderId)`                        | 取消指定订单     | orderId: string                                    | Promise<void>    |
| `cancelAllOrders()`                           | 取消所有挂单     | 无                                                 | Promise<void>    |
| `getOpenOrders()`                             | 获取当前所有挂单 | 无                                                 | Order[]          |

#### 4.3.2 OrderParams 参数规范

每个订单必须包含以下参数（使用 Drift SDK 类型）：

| 参数                | 类型                         | 说明                               |
| ------------------- | ---------------------------- | ---------------------------------- |
| `marketIndex`       | number                       | 市场索引                           |
| `side`              | OrderSide.BUY / SELL         | 买单或卖单                         |
| `orderType`         | OrderType.LIMIT / ORACLE     | 订单类型                           |
| `price`             | BN                           | 价格（整数形式）                   |
| `size`              | BN                           | 数量（整数形式）                   |
| `postOnly`          | PostOnlyParams.TRY_POST_ONLY | 必须设为 try_post_only             |
| `reduceOnly`        | boolean                      | 是否只减仓（卖单使用）             |
| `oraclePriceOffset` | number                       | 预言机偏移量（可选，用于动态价格） |

重要约束：

- **必须使用 post-only**：所有maker订单必须设置 `PostOnlyParams.TRY_POST_ONLY`，确保不会吃单
- **使用 Oracle Offset**：禁止硬编码价格，必须通过 `oraclePriceOffset` 相对预言机价格下单
- **整数精度**：所有金额和价格必须转换为 Drift 使用的整数形式（参见 SDK 常量 PRICE_PRECISION、SIZE_PRECISION）

#### 4.3.3 Drift SDK 使用要点

以下是在编写订单相关代码时必须遵守的 SDK 使用规范：

1. **获取精度常量**：从 SDK 导入 `PRICE_PRECISION`、`SIZE_PRECISION`、`QUOTE_PRECISION` 等常量，所有数值计算前必须将浮点数乘以对应精度转换为整数

2. **获取预言机价格**：
   ```typescript
   const oraclePrice = await driftClient.getOraclePrice(marketIndex);
   // 返回 BN 类型的整数价格
   ```

3. **构建偏移订单**：
   ```typescript
   // 在预言机价格下方 5 美元处挂单
   const oracleOffset = -5 * PRICE_PRECISION.toNumber();
   const orderParams = {
     marketIndex,
     side: OrderSide.BUY,
     orderType: OrderType.ORACLE,  // 使用 ORACLE 类型支持偏移
     price: new BN(0),  // 价格由 oracleOffset 决定
     size: orderSize,
     postOnly: PostOnlyParams.TRY_POST_ONLY,
     oraclePriceOffset: oracleOffset,
   };
   ```

4. **执行原子更新**：
   ```typescript
   // 必须使用 cancelAndPlaceOrders 保证原子性
   const txs = await driftClient.cancelAndPlaceOrders({
     cancels: [{ orderId: existingOrderId }],
     orders: [newOrderParams],
   });
   ```

---

## 5 策略模块

### 5.1 Strategy 类（库存感知报价）

**文件**: `src/strategy/Strategy.ts`

库存感知报价（Inventory Aware Quoting）的核心思想是：根据当前持仓情况动态调整买卖价差，减少库存风险。

#### 5.1.1 报价计算公式

假设配置中 `baseSpreadBps` 为基础价差（基点数），`skewFactor` 为库存偏移系数（0-1），`maxPosition` 为最大持仓量：

```
当前持仓 = currentPosition（正数为多头，负数为空头）
库存偏移 = currentPosition / maxPosition
买单价差 = baseSpreadBps + (库存偏移 * skewFactor * baseSpreadBps)
卖单价差 = baseSpreadBps - (库存偏移 * skewFactor * baseSpreadBps)
```

当持有多头时，买单价差增大（更难买入），卖单价差减小（更容易卖出），促进平仓；反之亦然。

#### 5.1.2 函数设计

| 函数                                     | 职责         | 输入                                | 输出                                                     |
| ---------------------------------------- | ------------ | ----------------------------------- | -------------------------------------------------------- |
| `calculateBidAsk(oraclePrice, position)` | 计算买卖报价 | oraclePrice: BN, position: Position | { bidPrice: BN, askPrice: BN, bidSize: BN, askSize: BN } |
| `calculateOrderSize(position)`           | 计算下单数量 | position: Position                  | { bidSize: BN, askSize: BN }                             |
| `calculateSpread()`                      | 计算当前价差 | position: Position                  | { bidSpread: number, askSpread: number }                 |

### 5.2 策略类型定义

**文件**: `src/strategy/types.ts`

必须定义以下类型：

```typescript
// 持仓方向
enum PositionSide {
  LONG = 'long',
  SHORT = 'short',
  NONE = 'none',
}

// 报价结果
interface QuoteResult {
  price: BN;           // 订单价格（整数）
  size: BN;            // 订单数量（整数）
  side: OrderSide;     // 订单方向
  reduceOnly: boolean; // 是否只减仓
  oracleOffset: number; // 预言机偏移量
}

// 策略配置
interface StrategyConfig {
  marketIndex: number;
  minOrderSize: BN;
  baseOrderSize: BN;
  spreadBps: number;
  skewFactor: number;
  maxPosition: BN;
}
```

---

## 6 做市主循环（状态机）

### 6.1 BotEngine 类

**文件**: `src/bot/BotEngine.ts`

BotEngine 是整个做市机器人的核心引擎，负责协调配置加载、Drift连接、订单执行和状态流转。

#### 6.1.1 主循环流程

机器人的做市逻辑完全由**成交事件**驱动，主循环遵循以下状态机流程：

```
┌─────────────────────────────────────────────────────────────────────┐
│                         程序启动                                      │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      初始化阶段                                       │
│  1. 加载配置                                                         │
│  2. 初始化日志                                                      │
│  3. 连接 Drift SDK                                                 │
│  4. 启动预言机监听                                                  │
│  5. 检查当前持仓                                                    │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
                    ┌───────────────────────────┐
                    │    账户无仓位 (NO_POSITION) │
                    └───────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       启动模式                                        │
│  • 记录当前预言机价格 P1                                             │
│  • 在价格下方一定间隔挂买单 B1 (Oracle - spread)                    │
│  • 启动 30 秒超时计时器                                              │
│  • 监听订单成交事件                                                  │
│                                                                       │
│  循环逻辑：                                                          │
│    若 30 秒后 B1 未完全成交：                                        │
│        若 当前预言机价格 > P1（价格上涨，偏离买单）：                 │
│            取消 B1                                                   │
│            重新计算报价并挂单 B1（更新 P1）                          │
│        若 当前预言机价格 <= P1：                                      │
│            保持 B1 不变，继续等待                                     │
│    若 B1 部分成交：                                                  │
│        取消未成交部分，按相同逻辑重新挂单                              │
│                                                                       │
│    直到 B1 完全成交 → 进入做市模式                                   │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
                    ┌───────────────────────────┐
                    │    账户有做多仓位 (IN_POSITION) │
                    └───────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       做市模式                                        │
│  • 获取当前预言机价格                                                │
│  • 计算库存偏移后的买卖价差                                          │
│  • 在价格下方挂买单 B1 (补仓单)：                                    │
│      - 使用 post-only                                               │
│      - 可使用 oraclePriceOffset                                      │
│      - 数量 = baseOrderSize                                          │
│  • 在价格上方挂卖单 S1 (止盈单)：                                    │
│      - 使用 post-only                                               │
│      - 设置 reduceOnly = true（只减仓）                              │
│      - 数量 = min(可平数量, baseOrderSize)                          │
│  • 监听 B1 和 S1 的成交事件                                         │
│                                                                       │
│  特殊情况处理：                                                       │
│      若当前持仓数量 < 目标数量：                                      │
│          S1 数量直接设置为账户可平的全部数量                         │
│                                                                       │
│  等待成交：                                                          │
│      任一订单完全成交 → 立即取消另一个订单 → 本轮结束                 │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
                    ┌───────────────────────────┐
                    │         本轮结束          │
                    └───────────────────────────┘
                                  │
                                  ▼
                    继续下一轮并判断账户是否有持仓
```

#### 6.1.2 函数设计

| 函数                          | 职责               | 输入                                            | 输出             |
| ----------------------------- | ------------------ | ----------------------------------------------- | ---------------- |
| `start()`                     | 启动机器人         | 无                                              | Promise<void>    |
| `stop()`                      | 停止机器人         | 无                                              | Promise<void>    |
| `runStartupMode()`            | 执行启动模式逻辑   | 无                                              | Promise<void>    |
| `runMarketMakingMode()`       | 执行做市模式逻辑   | 无                                              | Promise<void>    |
| `placeBidOrder()`             | 挂买单             | price: BN, size: BN                             | Promise<Order>   |
| `placeAskOrder()`             | 挂卖单             | price: BN, size: BN, reduceOnly: boolean        | Promise<Order>   |
| `cancelOppositeOrder(side)`   | 取消对手方订单     | side: OrderSide                                 | Promise<void>    |
| `checkTimeoutAndReposition()` | 检查超时并重新挂单 | order: Order, entryPrice: BN, entryTime: number | Promise<boolean> |
| `getCurrentPosition()`        | 获取当前持仓       | 无                                              | Position         |
| `syncState()`                 | 同步链上状态       | 无                                              | Promise<void>    |

#### 6.1.3 关键变量

| 变量名            | 类型                                 | 说明                   |
| ----------------- | ------------------------------------ | ---------------------- |
| `currentState`    | 'IDLE' / 'STARTUP' / 'MARKET_MAKING' | 当前状态机状态         |
| `entryPrice`      | BN                                   | 挂单时的预言机价格     |
| `entryTime`       | number                               | 挂单时的时间戳（毫秒） |
| `bidOrderId`      | string \| null                       | 当前买单 ID            |
| `askOrderId`      | string \| null                       | 当前卖单 ID            |
| `currentPosition` | Position                             | 当前持仓信息           |

### 6.2 EventHandler 类

**文件**: `src/bot/EventHandler.ts`

负责处理 Drift SDK 发出的各类事件，包括订单成交、订单取消、仓位变化等。

| 函数                       | 职责               | 输入                 | 输出 |
| -------------------------- | ------------------ | -------------------- | ---- |
| `onOrderFill(record)`      | 处理订单成交事件   | OrderFillRecord      | void |
| `onOrderCancel(record)`    | 处理订单取消事件   | OrderCancelRecord    | void |
| `onPositionChange(record)` | 处理仓位变化事件   | PositionChangeRecord | void |
| `onOracleUpdate(price)`    | 处理预言机价格更新 | BN                   | void |

---

## 7 风控模块

### 7.1 RiskManager 类

**文件**: `src/bot/RiskManager.ts`

在每次下单前必须调用风控检查，确保机器人运行在安全边界内。

| 函数                                         | 职责                 | 输入                                | 输出                     |
| -------------------------------------------- | -------------------- | ----------------------------------- | ------------------------ |
| `checkPositionLimit(position)`               | 检查持仓是否超限     | position: Position                  | boolean（超限返回false） |
| `checkExposure(usdcAmount)`                  | 检查敞口是否超限     | usdcAmount: BN                      | boolean（超限返回false） |
| `checkSlippage(estimatedPrice, filledPrice)` | 检查滑点是否过大     | estimatedPrice: BN, filledPrice: BN | boolean                  |
| `checkOrderSize(size)`                       | 检查订单数量是否合规 | size: BN                            | boolean                  |
| `emergencyClose()`                           | 紧急全平             | 无                                  | Promise<void>            |

---

## 8 数据库模块

### 8.1 Database 类

**文件**: `src/db/Database.ts`

SQLite 数据库连接管理。

| 函数              | 职责             | 输入 | 输出     |
| ----------------- | ---------------- | ---- | -------- |
| `initialize()`    | 初始化数据库连接 | 无   | void     |
| `close()`         | 关闭连接         | 无   | void     |
| `getConnection()` | 获取数据库连接   | 无   | Database |

### 8.2 AccountRepo 类

**文件**: `src/db/AccountRepo.ts`

负责记录账户权益快照。

#### 8.2.1 数据库表设计

```sql
-- 账户权益快照表
CREATE TABLE IF NOT EXISTS equity_snapshots (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp INTEGER NOT NULL,           -- 时间戳（秒）
    usdc_balance REAL NOT NULL,           -- USDC 可用余额
    total_collateral REAL NOT NULL,       -- 总保证金
    position_size REAL NOT NULL,         -- 持仓数量
    unrealized_pnl REAL NOT NULL,        -- 未实现盈亏
    market_index INTEGER NOT NULL,        -- 市场索引
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_equity_timestamp ON equity_snapshots(timestamp);
```

#### 8.2.2 函数设计

| 函数                              | 职责                   | 输入                       | 输出             |
| --------------------------------- | ---------------------- | -------------------------- | ---------------- |
| `saveSnapshot(equity)`            | 保存权益快照           | EquitySnapshot             | void             |
| `getSnapshots(limit)`             | 获取最近的快照记录     | limit: number              | EquitySnapshot[] |
| `getSnapshotsInRange(start, end)` | 获取指定时间范围的快照 | start: number, end: number | EquitySnapshot[] |

### 8.3 定时任务

机器人启动后，必须在后台启动一个定时任务（使用 `setInterval`），每隔 `equity_snapshot_interval_sec` 秒（配置文件中指定）执行一次 `saveSnapshot()`，记录当前账户状态。

---

## 9 Web 服务模块

### 9.1 服务器框架选择

推荐使用 Fastify 或 Express 作为 HTTP 服务器，配合 TSX 实现服务端渲染（SSR）。由于使用 HTMX 作为前端交互框架，服务器需要同时提供 API 端点和 HTML 页面。

### 9.2 路由设计

| 路径                    | 方法 | 功能                         |
| ----------------------- | ---- | ---------------------------- |
| `/`                     | GET  | 管理后台首页（Dashboard）    |
| `/api/status`           | GET  | 获取机器人运行状态           |
| `/api/toggle`           | POST | 启动/停止机器人              |
| `/api/config`           | GET  | 获取当前配置                 |
| `/api/config`           | POST | 更新配置（触发热重载）       |
| `/api/orders`           | GET  | 获取当前挂单列表             |
| `/api/position`         | GET  | 获取当前持仓                 |
| `/api/equity`           | GET  | 获取权益历史数据             |
| `/api/logs`             | GET  | 获取最近日志（用于前端轮询） |
| `/api/emergency/cancel` | POST | 紧急取消所有订单             |

### 9.3 前端页面设计

#### 9.3.1 Dashboard 页面

页面必须包含以下区块：

1. **状态概览卡片**
   - 机器人运行状态（运行中/已停止）
   - 当前预言机价格
   - 当前持仓数量和方向
   - 账户可用 USDC 权益
   - 账户总保证金

2. **控制面板**
   - 启动/停止按钮（HTMX 点击切换）
   - 紧急取消所有订单按钮（带二次确认）

3. **配置编辑器**
   - 显示 config.toml 内容的表单
   - 提交按钮（点击后触发热重载）

4. **实时日志窗口**
   - 使用 HTMX `hx-get="/api/logs" hx-trigger="every 2s"` 轮询
   - 滚动显示最新日志

5. **权益曲线图**
   - 使用 SVG 或 Chart.js 绘制最近 N 小时的权益变化曲线

#### 9.3.2 Tailwind CSS 样式规范

- 使用深色主题背景（bg-gray-900）
- 卡片使用 bg-gray-800 背景
- 按钮使用 rounded-lg 圆角
- 关键信息使用对应颜色高亮（绿色上涨、红色下跌、蓝色交易）
- 响应式布局，支持移动端查看

### 9.4 热重载机制

当用户在配置编辑器中提交新配置时：

1. 前端通过 HTMX POST `/api/config`
2. 后端接收新配置，写入 config.toml 文件
3. ConfigManager 监听到文件变化，触发 `configUpdated` 事件
4. BotEngine 监听该事件，动态更新策略参数
5. 前端刷新配置显示区域，反馈成功

---

## 10 错误处理与鲁棒性

### 10.1 全局异常捕获

在程序入口（index.ts）中必须设置全局异常处理器：

```typescript
process.on('uncaughtException', (error) => {
  logger.error('未捕获的异常', error);
  // 尝试取消所有订单
  // 保存当前状态到日志
  // 优雅退出
  process.exit(1);
});

process.on('unhandledRejection', (reason) => {
  logger.error('未处理的 Promise 拒绝', reason);
});
```

### 10.2 重试机制

对于网络请求（RPC 调用），必须实现指数退避重试：

| 场景               | 重试策略                              |
| ------------------ | ------------------------------------- |
| RPC 请求失败       | 最多重试 3 次，指数退避（1s, 2s, 4s） |
| 订单成交确认失败   | 最多重试 5 次，每 2 秒一次            |
| 预言机价格获取失败 | 使用缓存价格 + 标记数据过期           |

### 10.3 优雅退出

程序收到终止信号（SIGTERM、SIGINT）时，必须执行以下步骤：

1. 记录当前状态到日志
2. 取消所有挂单
3. 关闭数据库连接
4. 关闭 Drift SDK 订阅
5. 关闭日志文件句柄
6. 退出进程

---

## 11 开发流程指南

### 11.1 推荐的开发顺序

由于这是一个复杂的系统，建议按照以下顺序分阶段开发：

| 阶段 | 任务       | 交付物                                         |
| ---- | ---------- | ---------------------------------------------- |
| 1    | 环境搭建   | package.json, tsconfig.json, .env, config.toml |
| 2    | 基础设施   | Logger 模块，ConfigManager 模块                |
| 3    | Drift 连接 | DriftClientWrapper，OracleWatcher              |
| 4    | 订单执行   | OrderExecutor（原子更新）                      |
| 5    | 策略逻辑   | Strategy（库存感知报价）                       |
| 6    | 状态机     | BotEngine（主循环）                            |
| 7    | 数据库     | Database，AccountRepo                          |
| 8    | Web 服务   | 服务器、API、页面                              |
| 9    | 集成测试   | 端到端测试                                     |

### 11.2 测试策略

#### 11.2.1 单元测试

每个模块应有对应的单元测试，使用 Vitest 或 Jest 框架。测试文件命名规范为 `*.test.ts`。

#### 11.2.2 集成测试（关键）

在开发主循环逻辑时，必须在一个独立的测试文件中实现完整的业务逻辑测试：

1. 使用真实的钱包私钥和 Solana RPC
2. 使用预设的配置参数
3. 模拟完整的状态机流程
4. 验证订单挂单、成交、超时重试等行为

**重要**：测试时必须使用 Drift 的测试网（Devnet），而非主网。

### 11.3 Drift SDK 最佳实践

以下是编写 Drift 相关代码时必须遵守的规范：

1. **精度处理**：所有价格和数量必须使用 BN 类型，并乘以对应精度常量（PRICE_PRECISION、SIZE_PRECISION 等）

2. **预言机使用**：永远通过 `driftClient.getOraclePrice(marketIndex)` 获取价格，不要自行计算或缓存超过 30 秒

3. **订单类型**：Maker 订单必须使用 `OrderType.ORACLE` 配合 `oraclePriceOffset`，而非 `OrderType.LIMIT` 配合固定价格

4. **Post-Only**：`PostOnlyParams.TRY_POST_ONLY` 必须设置，确保不会吃单

5. **Reduce-Only**：卖单必须设置 `reduceOnly = true`，防止开空仓

6. **交易大小限制**：订单数量必须大于 `MINIMUM_ORDER_SIZE`（Drift 定义的常量），否则会被链上拒绝

7. **账户订阅**：DriftClient 初始化后必须调用 `subscribe()` 订阅账户变更，否则无法获取实时仓位

8. **退出清理**：程序退出前必须调用 `unsubscribe()` 取消订阅，防止内存泄漏

---

## 12 参考资料

以下参考资料必须仔细阅读并理解：

| 文档             | 链接                                                               | 关键内容               |
| ---------------- | ------------------------------------------------------------------ | ---------------------- |
| 做市入门         | https://docs.drift.trade/developers/market-makers/quickstart       | 基本概念、快速开始     |
| DLOB 做市方法    | https://docs.drift.trade/developers/market-makers/dlob-mm          | 具体实现细节、API 使用 |
| 生产级机器人架构 | https://docs.drift.trade/developers/market-makers/bot-architecture | 最佳实践、错误处理     |
| Drift SDK 基础   | https://docs.drift.trade/developers/drift-sdk/setup                | SDK 初始化、常用接口   |

---

## 13 代码规范

### 13.1 TypeScript 规范

- 必须使用 Strict Mode
- 所有函数必须有显式返回类型声明
- 优先使用 `const` 而非 `let`
- 使用 `unknown` 类型表示任意输入，必须进行类型守卫后才能使用

### 13.2 命名规范

| 类型       | 命名方式         | 示例                                   |
| ---------- | ---------------- | -------------------------------------- |
| 类名       | PascalCase       | `BotEngine`, `OrderExecutor`           |
| 函数名     | camelCase        | `placeBidOrder`, `getCurrentPosition`  |
| 常量       | UPPER_SNAKE_CASE | `PRICE_PRECISION`, `MAX_POSITION_SIZE` |
| 文件名     | kebab-case       | `bot-engine.ts`, `order-executor.ts`   |
| 数据库表名 | snake_case       | `equity_snapshots`, `order_records`    |

### 13.3 注释规范

- 公共 API 必须使用 JSDoc 注释
- 复杂业务逻辑必须添加中文注释解释意图
- 关键变量必须标注单位（如 "价格（整数形式，1e6 = $1）"）

---

## 14 验收标准

完成开发后，系统必须满足以下条件：

1. **功能验收**
   - [ ] 机器人能够成功连接到 Drift 并同步账户状态
   - [ ] 启动模式能够在无仓位时自动挂买单并等待成交
   - [ ] 做市模式能够同时挂买单和只减仓卖单
   - [ ] 订单成交后能够自动取消对手方订单
   - [ ] 30秒超时逻辑正常工作
   - [ ] 预言机偏移订单能够跟随价格浮动
   - [ ] 配置热重载功能正常
   - [ ] 前端页面能够实时显示状态和日志

2. **鲁棒性验收**
   - [ ] 网络异常能够自动重试
   - [ ] 异常退出时能够保存状态
   - [ ] 能够优雅处理预言机价格剧烈波动
   - [ ] 能够处理订单被部分成交的情况

3. **性能验收**
   - [ ] 订单响应延迟 < 1秒
   - [ ] 内存使用稳定，无泄漏
   - [ ] 数据库查询响应 < 100ms
